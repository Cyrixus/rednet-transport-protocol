--[[
    rtp.lua
    
    Client/Host definition file.
    
    Matthew DiBernardo [04.10.2012]
]]--

-- Includes

--  Constants
local rtpVersion = "RTP/0.1" -- Increment this on every feature revision.

local hostsFile = "/etc/hosts" -- Host overrides
local resolvFile = "/etc/resolv" -- Resolution File
local hostnameFile = "/etc/hostname" -- Hostname for this machine
local cacheFile = "/var/cache/rtpcache"

--[[
    splitUri()
    A function for splitting a uri into its host and address components.
]]
local function splitUri(uri)
    if uri == nil then
        return nil
    end

    -- Identify the protocol
    local protocol = nil
    protoEnd = string.find(uri, "//") -- find the end of the protocol, if it exists
    if protoEnd ~= nil then
        protocol = string.sub(uri, 1, protoEnd-1)
    else
        protocol = "rtp:"
    end
    
    -- RTP is the only valid protocol right now
    if protocol == "rtp:" then
        dest = string.sub(uri, protoEnd+2) -- Destination == URI - protocol
        
        -- Extract the host and address from the URI
        local host = nil
        local address = nil
        
        hostEnd = string.find(dest, "/")
        if hostEnd ~= nil then
            host = string.sub(dest, 1, hostEnd-1)
            address = string.sub(dest, hostEnd)
        else
            host = dest
            address = "/"
        end
        
        -- Success! Return the host and address
        return host, address
    end
    
    -- We couldn't parse the address, so return nothing
    return nil, nil
end

--[[
    Define Request and Response objects
]]

-- Base RtpMessage and header/body manipulation
RtpMessage = {_m = {["RTP-Version"] = rtpVersion}}

function RtpMessage:addHeader(headerName, headerValue)
    self._m["Header"][headerName] = headerValue
end

function RtpMessage:removeHeader(headerName)
    self._m["Header"][headerName] = nil
end

function RtpMessage:setBody(rtpMessage, contentType, content)
    addHeader(rtpMessage, "Content-Type", contentType)
    self._m["Body"] = content
end

function RtpMessage:create(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function RtpMessage:toString()
    return json.Encode(self._m)
end


-- Request Class
RtpRequest = RtpMessage:create()

function RtpRequest:create(method, uri)
    local host, address
    host, address = splitUri(uri)
    
    if host == nil and address == nil then
        return nil
    end
    
    o = RtpMessage:create()
    o._m["Type"] = "REQUEST"
    o._m["Method"] = method
    o._m["URI"] = uri
    return o
end


-- Response Class
RtpResponse = RtpMessage:create()

function RtpResponse:create(statusCode)
    o = RtpMessage:create()
    o._m["Type"] = "RESPONSE"
    o._m["Status"] = statusCode
    return o
end

--[[
    Define Client and Host objects
]]

-- Client Class
RtpClient = {}

function RtpClient:create(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function RtpClient:send(request)
    -- Step 1: Make sure we have an IP address and are connected to the network
        -- i.   Validate DHCP from resolvFile
        -- ii.  If DHCP returns NAK or does not exist
            --  Look for DHCP in range, 
        
    -- Step 2: Resolve target's Hostname to IP
        -- i.   Check hostsFile
        -- ii.  Check cacheFile
        -- iii. Resolve hostname via namespaces specified in resolvFile
        
    -- Step 3: Send the Message to IP via next-level Domain
        -- i.   Fetch the nameserver from
end


-- Rudimentary client/server implementations
function makeRequest(id, request)
    side = util.findPeripheralSide("modem")
    rednet.open(side)
    rednet.send(id, request)
    rednet.close(side)
end

function listen(timeout)
    side = util.findPeripheralSide("modem")
    rednet.open(side)
    id, message = rednet.receive(timeout)
    rednet.close(side)
    return id, message
end
