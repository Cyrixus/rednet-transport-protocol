--[[
    rtp.lua
    
    Client/Host definition file.
    
    Matthew DiBernardo [04.10.2012]
]]--

-- Includes
if not rtp_util then os.loadAPI("/lib/rtp_util") end
if not json then os.loadAPI("/lib/json") end

--  Constants
local rtpVersion = "RTP/0.1" -- Increment this on every feature revision.

local hostsFile = "/etc/hosts" -- Host overrides
local resolvFile = "/etc/resolv" -- Resolution File
local hostnameFile = "/etc/hostname" -- Hostname for this machine
local cacheFile = "/var/cache/rtpcache"



--[[
    Define Request and Response objects
]]

-- Base RtpMessage and header/body manipulation
RtpMessage = {_m = {["RTP-Version"] = rtpVersion}}

function RtpMessage:addHeader(headerName, headerValue)
    if self._m["Header"] == nil then
        self._m["Header"] = {}
    end
    self._m["Header"][headerName] = headerValue
end

function RtpMessage:removeHeader(headerName)
    if self._m["Header"] == nil then return end
    self._m["Header"][headerName] = nil
end

function RtpMessage:setBody(contentType, content)
    self:addHeader("Content-Type", contentType)
    self._m["Body"] = content
end

function RtpMessage:create(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function RtpMessage:toString()
    return json.Encode(self._m)
end


-- Request Class
RtpRequest = RtpMessage:create()

function RtpRequest:create(method, uri)
    local host, address
    host, address = rtp_util.splitUri(uri)
    
    if host == nil and address == nil then
        return nil
    end
    
    o = RtpMessage:create()
    o._m["Type"] = "REQUEST"
    o._m["Method"] = method
    o._m["URI"] = uri
    return o
end


-- Response Class
RtpResponse = RtpMessage:create()

function RtpResponse:create(statusCode)
    o = RtpMessage:create()
    o._m["Type"] = "RESPONSE"
    o._m["Status"] = statusCode
    return o
end

--[[
    Define Client and Host objects
]]

-- Client Class
RtpClient = {}

function RtpClient:create(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

    -- Step 1: Make sure we have an IP address and are connected to the network
        -- i.   Validate DHCP from resolvFile
        -- ii.  If DHCP returns NAK or does not exist
            --  Look for DHCP in range,

function RtpClient:send(request)
    -- Step 1: Resolve target's Hostname to IP
        -- i.   Check hostsFile
        -- ii.  Check cacheFile
        -- iii. Resolve hostname via namespaces specified in resolvFile
        
    -- Step 2: Send the Message to IP via next-level Domain
        -- i.   Send message to upstream DHCP/Router
end

-- When broadcasting, the URI acts as a RP filter, to determine how far upstream
-- to propagate the signal.
function RtpClient:broadcast(request)
    side = rtp_util.findPeripheralSide("modem")
end


-- Rudimentary client/server implementations
function makeRequest(id, request)
    side = rtp_util.findPeripheralSide("modem")
    rednet.open(side)
    rednet.send(id, request)
    rednet.close(side)
end

function listen(timeout)
    side = rtp_util.findPeripheralSide("modem")
    rednet.open(side)
    id, message = rednet.receive(timeout)
    rednet.close(side)
    return id, message
end
